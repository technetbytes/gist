from asyncio import constants
import redis
import pyfiglet
from threading import Lock
from pyexpat.errors import messages
from flask_socketio import SocketIO, emit, disconnect
from utilities.constant import *
from flask_session import Session
from flask import Flask, request, jsonify, render_template, session, flash, redirect, url_for, make_response
from core.celery_core import get_celery
from core.celery_api_task import CeleryApiTask
from config.setting import load_setting, Config
from utilities.smtp_server import get_context, init_smtp_server
from utilities.email import build_message, generate_email_body
from celery.result import AsyncResult
import argparse
from core.celery_events_handler import CeleryEventsHandler
from task_store.task_manager import TaskManager

# Set this variable to "threading", "eventlet" or "gevent" to test the
# different async modes, or leave it set to None for the application to choose
# the best option based on installed packages.
async_mode = None

# Flask application
flask_app = Flask(__name__)

# Set application secret_key
flask_app.config['SECRET_KEY'] = Config.get_complete_property('others','secret_key')
flask_app.config['SEND_INFO'] = Config.get_complete_property('email','sender') 

# init Socket-IO
socketio = SocketIO(flask_app, async_mode=async_mode)

thread = None
thread_lock = Lock()

# Initialize object celery
celerymq = get_celery(app=flask_app)

def init_celery_logger(app):
    parser = argparse.ArgumentParser(
        description='Monitor of task-related events, generated by a Celery worker.'
    )
    parser.add_argument(
        '--verbose', 
        action='store_true', 
        help='Detailed information about an event and a related task.'
    )
    args = parser.parse_args()
    events_handler = CeleryEventsHandler(app, None, args.verbose)
    import threading
    threading.Thread(target= events_handler.start_listening, daemon=True).start()


@celerymq.task(base=CeleryApiTask,bind=True)
def send_async_email(self, email_info):
    print("Start sending email ...")
    # Create a secure SSL context
    context = get_context()
    try:
        # message = build_message(email_info, flask_app.config['SEND_INFO'])
        # smtp_server = init_smtp_server()
        print("message sent ....")
        # smtp_server.send_message(message)
    except Exception as exc:
        # Print any error messages to stdout
        print("error :- ",exc)
        raise self.retry(exc=exc)

@flask_app.route('/', methods=['GET', 'POST'])
def index():
    if request.method == 'GET':
        return render_template('index.html', email=session.get('email', ''), async_mode=socketio.async_mode)

@flask_app.route('/api/v1/task_status', methods=['GET'])
def task_status():
    args = request.args
    task_id = args.get('taskid')
    if task_id is not None:
        task_result = celerymq.AsyncResult(task_id)
        return task_result.state

@flask_app.route('/api/v1/send_email', methods=['POST'])
def send_email():
    #fgenerate email body from request object base on request type 
    email_data = generate_email_body(request)
    #send async email
    task = send_async_email.delay(email_data)
    #Store task info in redis-cache   
    TaskManager.create_new_task(MESSAGE_TYPE_EMAIL, task)
    
    response = make_response(
                jsonify(
                     message="E-mail sent.",
                    category="EMAIL",
                    status=201,
                    data=email_data),
                201,
            )
    response.headers["Content-Type"] = "application/json"
    return response

@socketio.event
def my_event(message):
    session['receive_count'] = session.get('receive_count', 0) + 1
    emit('my_response',
         {'data': message['data'], 'count': session['receive_count']})

@socketio.event
def server_ping():
    emit('server_pong')

@socketio.event
def connect():
    emit('my_response', {'data': 'Connected', 'count': 0})

@socketio.on('disconnect')
def test_disconnect():
    print('Client disconnected', request.sid)


if __name__ == '__main__':
    # run application using socket
    result = pyfiglet.figlet_format("LWMQ")
    print(result)
    ##init celery logger
    init_celery_logger(celerymq)
    ##init server socket listener
    socketio.run(flask_app,host='0.0.0.0', port=10001)
    
    from task_store.status import Status
    from task_store.task import Task, Tasks
    import json
    import datetime
    from task_store.task_manager import Welcome3, Welcome3Condition, ConditionCondition

    #TaskManager.create_new_task("EMAIL","afaf")
    # tk1  = Status("email_start_1",datetime.datetime.now(), datetime.datetime.now(), "Passed")
    # tk2  = Status("email_start_1",datetime.datetime.now(), datetime.datetime.now(), "Passed")
    # conditions = [tk1, tk2]
    # #print(conditions)
    # image_label_col = Task("email","id....", "done", conditions)
    # print(image_label_col)
    # #print(json.dumps(image_label_col, default=default))

    # _tasks = []

    # conditions = []
    # status_1 = ConditionCondition("START","DATE_TIME","Task is Started")
    # status_2 = ConditionCondition("DONE","DATE_TIME","Task is Done")
    # conditions.append(status_1)
    # conditions.append(status_2)
    # new_task = Welcome3Condition("type", "fafa", "init", conditions)
    # _tasks.append(new_task)

    # conditions_1 = []
    # status_3 = ConditionCondition("START","DATE_TIME_2","Task is Started")
    # status_4 = ConditionCondition("DONE","DATE_TIME_2","Task is Done")
    # conditions_1.append(status_3)
    # conditions_1.append(status_4)
    # new_task2 = Welcome3Condition("type2", "faf2", "init2", conditions_1)
    # _tasks.append(new_task)

    # tasks = Welcome3(_tasks)
    # print(json.dumps(tasks))

    # after this my original code

    # conditions = []
    # status_1 = Status("START","DATE_TIME","Task is Started")
    # status_2 = Status("DONE","DATE_TIME","Task is Done")
    # conditions.append(status_1)
    # conditions.append(status_2)
    # _tasks = []
    # new_task = Task("type", "fafa", "init", conditions)
    # _tasks.append(new_task)

    # conditions_1 = []
    # status_3 = Status("START","DATE_TIME_2","Task is Started")
    # status_4 = Status("DONE","DATE_TIME_2","Task is Done")
    # conditions_1.append(status_3)
    # conditions_1.append(status_4)
    # new_task2 = Task("type2", "faf2", "init2", conditions_1)
    # _tasks.append(new_task2)
    # tasks = Tasks(_tasks)
    # #print("---->",tasks.to_json())
    # s = TaskManager.testing_create_new_task(tasks.to_json())
    # #print("@@@@@@@",type(s))
    # js =json.loads(json.dumps(s))



    # print("======***====",type(js['conditions']))
    # print("======INITSELF====",js['conditions'])
    # print("===========",type(js['conditions'][0]))
    # print("======INITSELF====",js['conditions'])
    # print(len(js['conditions']))
    # x = json.loads(js['conditions'][1])
    # print(len(x))
    # print(x)
    #print(json.loads(json.dumps(js['conditions']))[0])
    #print("",TaskManager.function_2(js['conditions'],"fafa"))